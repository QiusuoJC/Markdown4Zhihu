# 基于格上困难问题的密码系统和 GGH 公钥密码系统

[TOC]

## Cryptosystems based on hard lattice problems

> 这一节对应教材的 6.7.

在20世纪90年代中期，几个基于高维格 $L$ 的密码系统被提出，其底层的困难问题为最短向量问题(SVP)和/或最近向量问题(CVP)。其中最重要的有：Ajtai-Dwork 密码系统，由 Goldreich、Goldwasser 和 Halevi 提出的 GGH 密码系统，以及由 Hoffstein、Pipher 和 Silverman 提出的 NTRU 密码系统。

引入这些密码系统的动机有两个方面。首先，基于各种难解的数学问题的密码系统无疑是有意义的，因为如果一个数学难题被破解，并不会影响所有系统的安全性。其次，基于格的密码系统通常比基于分解问题或离散对数问题的密码系统更快，如 ElGamal、RSA 和 ECC。粗略地说，为了达到 $k$ 比特的安全性，ElGamal、RSA 和 ECC 的加密和解密需要 $O(k^3)$ 次运算，而基于格的系统只需要 $O(k^2)$​ 次运算。此外，基于格的系统所使用的简单线性代数运算在硬件和软件中非常容易实现。然而，目前我们对基于格的密码系统的安全性分析还远未像对基于分解和离散对数的系统那样得到充分的理解。因此，尽管基于格的系统是当前研究的热点，但与前面的密码系统相比，它们在实际中的应用还很少。

Ajtai 和 Dwork 证明了他们的 Ajtai-Dwork 系统是可证明安全的，除非最坏情况下的格问题可以在多项式时间内解决。与这一重要的理论结果相对的是一个实际限制，即密钥大小需要为 $O(n^4)$，这会导致密钥非常庞大。Nguyen 和 Stern 随后证明，任何实用且高效的 Ajtai-Dwork 系统实现都是不安全的。

GGH 密码系统的基本原理(我们将在后面作更详细地解释)是对我们已经讨论过的思想的直接应用。Alice 的私钥是格 $L$ 的一个好的基底 $\mathcal{B}_\text{good}$，而她的公钥是 $L$ 的一个坏的基底 $\mathcal{B}_\text{bad}$。Bob 的消息是一个二进制向量 $m$，用来形成 $\mathcal{B}_\text{bad}$ 中向量的线性组合 $\sum m_iv_i^{\text{bad}}$。然后，他通过添加一个小的随机向量 $r$ 来扰动这个和。由此产生的向量 $w$ 与格向量 $v$ 之间的差异为向量 $r$。由于 Alice 知道 $L$ 的一个好的基，她可以使用 Babai 的算法来找到 $v$，然后用坏的基表示 $v$ 以恢复 $m$。另一方面，Eve 只知道坏的基 $\mathcal{B}_\text{bad}$，所以她无法在 $L$​ 中求解 CVP。

GGH 密码系统中的公钥是格 $L$ 的一个坏的基，因此它由 $n^2$ 个(大)数组成。在最初的版本中，密钥大小为 $O(n^3\log n)$，但使用 Micciancio 的一个想法后，可以将密钥大小减小到 $O(n^2\log n)$ 比特。

Goldreich、Goldwasser 和 Halevi 推测，对于 $n>300$，GGH 所依赖的 CVP 是难以解决的。然而在当时，LLL 类型的格约化算法在高维格上的有效性还没有被仔细研究。Nguyen 表明，对原始 GGH 加密方案的转换可以将问题简化为一个更容易的 CVP。这使他能够解决提出的维数高达 350 的 GGH 挑战问题。对于 $n>400$，公钥大约为 128 KB。

NTRU 公钥密码系统很自然地用多项式商环来描述。然而，NTRU 所基于的困难问题很容易转化为一类特殊格中的 SVP(用于密钥恢复)或 CVP(用于明文恢复)。NTRU 格(将在后面讲述)是偶数维 $n=2N$ 的格，由所有满足
$$
y\equiv xH\ (\text{mod}\ q)
$$
的向量 $(x,y) \in \mathbb{Z}^{2N}$ 组成，其中 $q$ 是一个固定的正整数，也是一个公共参数，在实际中，$q = O(n)$。矩阵 $H$ 是公钥，是一个 $N\times N$ 的循环矩阵。这意味着 H 的每一行都是前一行的循环移位，于是为了描述 $H$，只需指定其第一行即可。因此，公钥的大小为 $O(n\log n)$，明显小于 GGH。

NTRU 的私钥是一个短向量 $(f,g)\in L$。由短向量 $(f,g)$ 及其部分循环移位组成的集合在 $L$ 中给出了 $N = \frac{1}{2} \dim(L)$ 个独立的短向量。这使得 $(f,g)$ 的所有者能够在 $L$ 中求解 CVP 的某些实例，从而恢复加密的明文。因此，明文的安全性依赖于在 NTRU 格中求解 CVP 的难度。此外，向量 $(f,g)$ 及其循环移位几乎可以肯定地说是 $L$ 中最短的非零向量，因此 NTRU 也容易受到 SVP 解的攻击。

## The GGH public key cryptosystem

> 这一节对应教材的 6.8.

Alice 首先选择一组线性无关的向量：
$$
v_1,v_2,\dots,v_n \in \mathbb{Z}^n
$$
彼此较为正交(reasonably orthogonal to one another)。为做到这一点，可以固定一个参数 $d$ 并从 $-d$ 到 $d$ 之间随机选择 $v_1,\dots,v_n$ 的坐标。Alice 可以检查 Hadamard 比率来检查所选择的基是好的。这组向量便是 Alice 的私钥。为了叙述方便，我们令 $V$ 表示行向量为 $v_1,\dots,v_n$ 的 $n\times n$ 矩阵，$L$ 是由这组向量生成的格。

Alice 随后选择一个 $n\times n$ 的整系数矩阵 $U$，满足行列式 $\det(U)=\pm 1$。创建 $U$​ 的一种方法是将大量随机选择的初等矩阵(elementary matrix)相乘。

> 初等矩阵的行列式只有三种情况：
>
> 1. 两行(列)互换：$\det(P)=-1$；
> 2. 某行乘以一非零常数 $k$：$\det(D)=k$；
> 3. 第 $i$ 行加上第 $j$ 行的 $m$ 倍：$\det(T)=1$​；
>
> 设 $E_1,\dots,E_n$ 是随机选择的初等矩阵，
> $$
> \det(U)=\det(E_1\cdots E_n)=\det(E_1)\cdots\det(E_n)=1
> $$
> 则在选择时需要注意上面的3条性质，使得最后的行列式为1即可。

Alice 计算：
$$
W=UV.
$$
那么矩阵 $W$ 的行向量 $w_1,\dots,w_n$ 就是 $L$ 的一个新的基。令其作为 Alice 的公钥。

当 Bob 想要发送给 Alice 一个消息，他选择一个小向量 $m$ 作为明文，例如 $m$ 可以是一个二进制向量(binary vector)。Bob 同时也选择一个小的随机扰动向量 $r$ 作为临时密钥(ephemeral key)。例如，Bob 可能在区间 $[-\delta, \delta]$ 随机选择 $r$ 的坐标，$\delta$ 是一个固定的公共参数。他随后计算向量：
$$
e=mW+r=\sum_{i=1}^n m_iw_i+r,
$$
作为密文。注意到，$e$ 不是一个格点，但是其非常接近格点 $mW$，因为 $r$ 非常小。

解密过程很直接。Alice 根据 Babai 的算法，利用好的基底 $v_1,\dots,v_n$ 来寻找格 $L$ 中最接近 $e$ 的向量。由于她使用的是好的基且 $r$ 很小，所以她找到的格向量就是 $mW$。随后，她再右乘一个 $W^{-1}$ 来恢复 $m$。下图总结了 GGH 密码系统。

<p align="center">
  <figure>
  <img src="D:\程建勋学习\大三下\创新资助计划\LBC\img\13.png" style="zoom:67%;"/>
      <figcaption>图 1. GGH 密码系统，源自《An Introduction to Mathematical Cryptography》</figcaption></figure>
      </p>



*Example.* 我们以 3 维为例来解释 GGH 密码系统的原理。对于 Alice 的私有的好基我们令：
$$
v_1=(-97,19,19),\ v_2 = (-26,30,86),\ v_3=(-184,-64,78).
$$
由 $v_1,v_2,v_3$ 扩张成的格 $L$ 的行列式为 $\det(L)=859516$，Hadamard 比率为：
$$
\mathcal{H}(v_1,v_2,v_3)=\left(\frac{\det(L)}{\left\lVert v_1\right\rVert \left\lVert v_2\right\rVert\left\lVert v_3\right\rVert} \right)^{1/3}\approx 0.74620.
$$
Alice 用矩阵 $U$ 乘以私有的基底：
$$
U=
\left(
\begin{array}
44327 & -15447 & 23454\\
3297 &-11770 & 17871\\
5464 & -19506 & 29617
\end{array}
\right),
$$
其行列式 $\det(U)=-1$，创建得到公共基底：
$$
\begin{align}
w_1&=(−4179163,−1882253,583183),\\
w_2&=(−3184353,−1434201,444361),\\
w_3&=(−5277320,−2376852,736426).
\end{align}
$$
这组公共基底的 Hadamard 比率就非常小了：
$$
\mathcal{H}(w_1,w_2,w_3)=\left(\frac{\det(L)}{\left\lVert w_1\right\rVert \left\lVert w_2\right\rVert\left\lVert w_3\right\rVert} \right)^{1/3}\approx 0.0000208.
$$
Bob 决定发送 $m = (86,−35,−32)$ 给 Alice，并添加一个随机扰动 $r =(−4,−3,2)$。相应的密文为：
$$
\begin{align}
e&=(86,−35,−32)\left(
\begin{array}
−4179163&−1882253& 583183\\
−3184353&−1434201&444361\\
−5277320&−2376852&736426
\end{array}
\right)+(−4,−3,2)\\
&=(−79081427,−35617462,11035473).
\end{align}
$$
Alice 用 Babai 的算法进行解密。她首先将 $e$ 写成私有基底的实系数线性组合的形式：
$$
e\approx 81878.97v_1 −292300.00v_2 +443815.04v_3.
$$
她将系数四舍五入到最近的整数并计算得到格向量：
$$
v=81879v_1 −292300v_2 +443815v_3 =(−79081423,−35617459,11035471)
$$
非常接近于 $e$。随后她恢复 $m$ 通过将 $v$​ 表示为公共基的线性组合的形式，并从中提取出系数，
$$
v =86w_1−35w_2−32w_3.
$$
现在假设 Eve 尝试解密 Bob 的消息，但是她只知道公共的基底 $w_1,w_2,w_3$。如果用公共基来运行 Babai 的算法，她会得到：
$$
e \approx 75.76w_1-34.52w_2-24.18w_3.
$$
四舍五入，她便会得到一个格向量：
$$
v^{'}=75w_1-35w_2-24w_3=(−79508353,−35809745,11095049)
$$
也比较接近 $e$。然而，这个格向量却给出了错误的明文 $(76,−35,−24)$，而不是 $m = (86,−35,−32)$。对比 Babai 算法在不同基底下的表现是很有启发性的。我们发现：
$$
\left\lVert e-v\right\rVert \approx 5.3852 \quad \text{and} \quad \left\lVert e-v^{'}\right\rVert \approx472000.
$$

当然了，GGH 密码系统在 3 维上本身就不安全，因为即使我们使用足够大的数字来使穷举搜索变得不切实际，在低维空间中仍然有高效的算法来寻找好的基。在二维空间中，一个寻找好基的算法最早可以追溯到 Gauss。一个强大的推广到任意维度的算法，被称为 LLL 算法，将在后面介绍。

*Remark.* 我们观察到，GGH 是一个概率加密系统的例子，因为由于随机扰动 r 的选择，单个明文会导致许多不同的密文。如果 Bob 两次使用不同的随机扰动发送相同的消息，或者使用相同的随机扰动发送不同的消息，这都可能会导致潜在的危险。因此，在实践中，随机扰动 $r$ 是通过将 hash 函数应用于明文 $m$ 来确定的。

*Remark.* GGH 的一个替代版本颠倒了 $m$ 和 $r$ 的角色，因此密文具有 $e = rW + m$ 的形式。Alice 通过计算最接近 $e$ 的格向量来找到 $rW$，然后她将明文恢复为 $m = e - rW$。





